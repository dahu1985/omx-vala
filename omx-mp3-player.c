/* omx-mp3-player.c generated by valac, the Vala compiler
 * generated from omx-mp3-player.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <OMX_Core.h>
#include <OMX_Component.h>
#include <omx-utils.h>
#include <bellagio/tsemaphore.h>

#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))


extern FILE* fd;
FILE* fd = NULL;
extern void* audiodec_handle;
extern void* audiosink_handle;
void* audiodec_handle = NULL;
void* audiosink_handle = NULL;
extern OMX_BUFFERHEADERTYPE** in_buffer_audiosink;
extern gint in_buffer_audiosink_length1;
OMX_BUFFERHEADERTYPE** in_buffer_audiosink = NULL;
gint in_buffer_audiosink_length1 = 0;
static gint in_buffer_audiosink_size = 0;
extern OMX_BUFFERHEADERTYPE** in_buffer_audiodec;
extern gint in_buffer_audiodec_length1;
OMX_BUFFERHEADERTYPE** in_buffer_audiodec = NULL;
gint in_buffer_audiodec_length1 = 0;
static gint in_buffer_audiodec_size = 0;
extern OMX_BUFFERHEADERTYPE** out_buffer_audiodec;
extern gint out_buffer_audiodec_length1;
OMX_BUFFERHEADERTYPE** out_buffer_audiodec = NULL;
gint out_buffer_audiodec_length1 = 0;
static gint out_buffer_audiodec_size = 0;
extern tsem_t audiodec_sem;
tsem_t audiodec_sem = {0};
extern tsem_t audiosink_sem;
tsem_t audiosink_sem = {0};
extern tsem_t eos_sem;
tsem_t eos_sem = {0};

void play (const char* filename);
void _main (char** args, int args_length1);
void get_handles (void);
void handle_print_info (const char* name, void* handle);
void set_state (OMX_STATETYPE state);
void allocate_buffers (void);
void wait_for_state_set (void);
void move_buffers (void);
void wait_for_eos (void);
void free_buffers (void);
void free_handles (void);
OMX_ERRORTYPE audiodec_event_handler (void* component, OMX_EVENTTYPE event, guint32 data1, guint32 data2);
static OMX_ERRORTYPE _audiodec_event_handler_omx_event_handler_func (void* component, gpointer self, OMX_EVENTTYPE event, guint32 data1, guint32 data2, void* event_data);
OMX_ERRORTYPE audiodec_empty_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer);
static OMX_ERRORTYPE _audiodec_empty_buffer_done_omx_empty_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer);
OMX_ERRORTYPE audiodec_fill_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer);
static OMX_ERRORTYPE _audiodec_fill_buffer_done_omx_fill_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer);
OMX_ERRORTYPE audiosink_event_handler (void* component, OMX_EVENTTYPE event, guint32 data1, guint32 data2);
static OMX_ERRORTYPE _audiosink_event_handler_omx_event_handler_func (void* component, gpointer self, OMX_EVENTTYPE event, guint32 data1, guint32 data2, void* event_data);
OMX_ERRORTYPE audiosink_empty_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer);
static OMX_ERRORTYPE _audiosink_empty_buffer_done_omx_empty_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer);
#define AUDIODEC_COMPONENT "OMX.st.audio_decoder.mp3.mad"
#define AUDIOSINK_COMPONENT "OMX.st.alsa.alsasink"
#define N_BUFFERS 2
#define BUFFER_OUT_SIZE 32768
#define BUFFER_IN_SIZE 4096
void read_buffer_from_fd (OMX_BUFFERHEADERTYPE* buffer);

const OMX_CALLBACKTYPE audiodec_callbacks = {_audiodec_event_handler_omx_event_handler_func, _audiodec_empty_buffer_done_omx_empty_buffer_done_func, _audiodec_fill_buffer_done_omx_fill_buffer_done_func};
const OMX_CALLBACKTYPE audiosink_callbacks = {_audiosink_event_handler_omx_event_handler_func, _audiosink_empty_buffer_done_omx_empty_buffer_done_func, NULL};


void _main (char** args, int args_length1) {
	if (args_length1 != 2) {
		g_print ("%s <file.mp3>\n", args[0]);
		return;
	}
	play (args[1]);
}


int main (int argc, char ** argv) {
	g_type_init ();
	_main (argv, argc);
	return 0;
}


void play (const char* filename) {
	FILE* _tmp0_;
	g_return_if_fail (filename != NULL);
	fd = (_tmp0_ = fopen (filename, "rb"), _fclose0 (fd), _tmp0_);
	if (fd == NULL) {
		g_print ("Error opening %s", filename);
		return;
	}
	OMX_Init ();
	get_handles ();
	handle_print_info ("audiodec", audiodec_handle);
	handle_print_info ("audiosink", audiosink_handle);
	set_state (OMX_StateIdle);
	allocate_buffers ();
	wait_for_state_set ();
	set_state (OMX_StateExecuting);
	wait_for_state_set ();
	move_buffers ();
	wait_for_eos ();
	set_state (OMX_StateIdle);
	wait_for_state_set ();
	set_state (OMX_StateLoaded);
	free_buffers ();
	wait_for_state_set ();
	free_handles ();
	OMX_Deinit ();
}


static OMX_ERRORTYPE _audiodec_event_handler_omx_event_handler_func (void* component, gpointer self, OMX_EVENTTYPE event, guint32 data1, guint32 data2, void* event_data) {
	return audiodec_event_handler (component, event, data1, data2);
}


static OMX_ERRORTYPE _audiodec_empty_buffer_done_omx_empty_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer) {
	return audiodec_empty_buffer_done (component, buffer);
}


static OMX_ERRORTYPE _audiodec_fill_buffer_done_omx_fill_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer) {
	return audiodec_fill_buffer_done (component, buffer);
}


static OMX_ERRORTYPE _audiosink_event_handler_omx_event_handler_func (void* component, gpointer self, OMX_EVENTTYPE event, guint32 data1, guint32 data2, void* event_data) {
	return audiosink_event_handler (component, event, data1, data2);
}


static OMX_ERRORTYPE _audiosink_empty_buffer_done_omx_empty_buffer_done_func (void* component, gpointer self, OMX_BUFFERHEADERTYPE* buffer) {
	return audiosink_empty_buffer_done (component, buffer);
}


void get_handles (void) {
	OMX_GetHandle (&audiodec_handle, AUDIODEC_COMPONENT, NULL, &audiodec_callbacks);
	OMX_GetHandle (&audiosink_handle, AUDIOSINK_COMPONENT, NULL, &audiosink_callbacks);
}


static const char* omx_dir_to_string (OMX_DIRTYPE self) {
	const char* result;
	switch (self) {
		case OMX_DirInput:
		{
			result = "Omx.Dir.Input";
			return result;
		}
		case OMX_DirOutput:
		{
			result = "Omx.Dir.Output";
			return result;
		}
		default:
		{
			result = "(uknnown)";
			return result;
		}
	}
}


void handle_print_info (const char* name, void* handle) {
	OMX_PORT_PARAM_TYPE _tmp0_ = {0};
	OMX_PORT_PARAM_TYPE param;
	OMX_PARAM_PORTDEFINITIONTYPE _tmp1_ = {0};
	OMX_PARAM_PORTDEFINITIONTYPE port_definition;
	g_return_if_fail (name != NULL);
	g_return_if_fail (handle != NULL);
	param = (memset (&_tmp0_, 0, sizeof (OMX_PORT_PARAM_TYPE)), _tmp0_);
	omx_structure_init (&param);
	OMX_GetParameter (handle, (guint) OMX_IndexParamAudioInit, &param);
	port_definition = (memset (&_tmp1_, 0, sizeof (OMX_PARAM_PORTDEFINITIONTYPE)), _tmp1_);
	omx_structure_init (&port_definition);
	g_print ("%s (%p)\n", name, handle);
	{
		guint i;
		i = (guint) param.nStartPortNumber;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < param.nPorts)) {
					break;
				}
				g_print ("\tPort %u:\n", i);
				port_definition.nPortIndex = (guint32) i;
				OMX_GetParameter (handle, (guint) OMX_IndexParamPortDefinition, &port_definition);
				g_print ("\t\thas mime-type %s\n", port_definition.format.audio.cMIMEType);
				g_print ("\t\thas direction %s\n", omx_dir_to_string (port_definition.eDir));
				g_print ("\t\thas %u buffers of size %u\n", (guint) port_definition.nBufferCountActual, (guint) port_definition.nBufferSize);
			}
		}
	}
}


void set_state (OMX_STATETYPE state) {
	OMX_SendCommand (audiodec_handle, OMX_CommandStateSet, (guint) state, NULL);
	OMX_SendCommand (audiosink_handle, OMX_CommandStateSet, (guint) state, NULL);
}


void allocate_buffers (void) {
	OMX_BUFFERHEADERTYPE** _tmp0_;
	OMX_BUFFERHEADERTYPE** _tmp1_;
	OMX_BUFFERHEADERTYPE** _tmp2_;
	in_buffer_audiodec = (_tmp0_ = g_new0 (OMX_BUFFERHEADERTYPE*, N_BUFFERS + 1), in_buffer_audiodec = (g_free (in_buffer_audiodec), NULL), in_buffer_audiodec_length1 = N_BUFFERS, in_buffer_audiodec_size = in_buffer_audiodec_length1, _tmp0_);
	out_buffer_audiodec = (_tmp1_ = g_new0 (OMX_BUFFERHEADERTYPE*, N_BUFFERS + 1), out_buffer_audiodec = (g_free (out_buffer_audiodec), NULL), out_buffer_audiodec_length1 = N_BUFFERS, out_buffer_audiodec_size = out_buffer_audiodec_length1, _tmp1_);
	in_buffer_audiosink = (_tmp2_ = g_new0 (OMX_BUFFERHEADERTYPE*, N_BUFFERS + 1), in_buffer_audiosink = (g_free (in_buffer_audiosink), NULL), in_buffer_audiosink_length1 = N_BUFFERS, in_buffer_audiosink_size = in_buffer_audiosink_length1, _tmp2_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				if (!_tmp3_) {
					i++;
				}
				_tmp3_ = FALSE;
				if (!(i < N_BUFFERS)) {
					break;
				}
				OMX_AllocateBuffer (audiodec_handle, &in_buffer_audiodec[i], (guint) 0, NULL, (guint) BUFFER_IN_SIZE);
				OMX_AllocateBuffer (audiodec_handle, &out_buffer_audiodec[i], (guint) 1, NULL, (guint) BUFFER_OUT_SIZE);
				OMX_AllocateBuffer (audiosink_handle, &in_buffer_audiosink[i], (guint) 0, NULL, (guint) BUFFER_OUT_SIZE);
			}
		}
	}
}


void read_buffer_from_fd (OMX_BUFFERHEADERTYPE* buffer) {
	g_return_if_fail (buffer != NULL);
	buffer->nOffset = (gsize) 0;
	buffer->nFilledLen = fread (buffer->pBuffer, 1, buffer->nAllocLen, fd);
}


void move_buffers (void) {
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < N_BUFFERS)) {
					break;
				}
				read_buffer_from_fd (in_buffer_audiodec[i]);
				OMX_EmptyThisBuffer (audiodec_handle, in_buffer_audiodec[i]);
				OMX_FillThisBuffer (audiodec_handle, out_buffer_audiodec[i]);
			}
		}
	}
}


void free_buffers (void) {
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < N_BUFFERS)) {
					break;
				}
				OMX_FreeBuffer (audiodec_handle, (guint) 0, in_buffer_audiodec[i]);
				OMX_FreeBuffer (audiodec_handle, (guint) 1, out_buffer_audiodec[i]);
				OMX_FreeBuffer (audiosink_handle, (guint) 0, in_buffer_audiosink[i]);
			}
		}
	}
}


void free_handles (void) {
	OMX_FreeHandle (audiodec_handle);
	OMX_FreeHandle (audiosink_handle);
}


void wait_for_state_set (void) {
	tsem_down (&audiodec_sem);
	tsem_down (&audiosink_sem);
}


void wait_for_eos (void) {
	g_print ("Waiting for eos\n");
	tsem_down (&eos_sem);
}


OMX_ERRORTYPE audiodec_event_handler (void* component, OMX_EVENTTYPE event, guint32 data1, guint32 data2) {
	OMX_ERRORTYPE result;
	g_return_val_if_fail (component != NULL, 0);
	switch (event) {
		case OMX_EventCmdComplete:
		{
			if (data1 == OMX_CommandStateSet) {
				tsem_up (&audiodec_sem);
			}
			break;
		}
		default:
		{
			break;
		}
	}
	result = OMX_ErrorNone;
	return result;
}


static void omx_buffer_header_set_eos (OMX_BUFFERHEADERTYPE* self) {
	g_return_if_fail (self != NULL);
	self->nFlags = self->nFlags | ((guint32) OMX_BUFFERFLAG_EOS);
}


OMX_ERRORTYPE audiodec_empty_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer) {
	OMX_ERRORTYPE result;
	g_return_val_if_fail (component != NULL, 0);
	g_return_val_if_fail (buffer != NULL, 0);
	if (feof (fd)) {
		result = OMX_ErrorNone;
		return result;
	}
	read_buffer_from_fd (buffer);
	if (feof (fd)) {
		g_print ("Setting eos flag\n");
		omx_buffer_header_set_eos (buffer);
	}
	result = OMX_EmptyThisBuffer (audiodec_handle, buffer);
	return result;
}


static gboolean omx_buffer_header_get_eos (OMX_BUFFERHEADERTYPE* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = (self->nFlags & OMX_BUFFERFLAG_EOS) != 0;
	return result;
}


OMX_ERRORTYPE audiodec_fill_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer) {
	OMX_ERRORTYPE result;
	g_return_val_if_fail (component != NULL, 0);
	g_return_val_if_fail (buffer != NULL, 0);
	if (omx_buffer_header_get_eos (buffer)) {
		g_print ("Got eos flag\n");
		tsem_up (&eos_sem);
		result = OMX_ErrorNone;
		return result;
	}
	result = OMX_EmptyThisBuffer (audiosink_handle, buffer);
	return result;
}


OMX_ERRORTYPE audiosink_event_handler (void* component, OMX_EVENTTYPE event, guint32 data1, guint32 data2) {
	OMX_ERRORTYPE result;
	g_return_val_if_fail (component != NULL, 0);
	switch (event) {
		case OMX_EventCmdComplete:
		{
			if (data1 == OMX_CommandStateSet) {
				tsem_up (&audiosink_sem);
			}
			break;
		}
		default:
		{
			break;
		}
	}
	result = OMX_ErrorNone;
	return result;
}


OMX_ERRORTYPE audiosink_empty_buffer_done (void* component, OMX_BUFFERHEADERTYPE* buffer) {
	OMX_ERRORTYPE result;
	g_return_val_if_fail (component != NULL, 0);
	g_return_val_if_fail (buffer != NULL, 0);
	result = OMX_FillThisBuffer (audiodec_handle, buffer);
	return result;
}




