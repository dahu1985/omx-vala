/* gstgomx.c generated by valac, the Vala compiler
 * generated from gstgomx.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>


#define GST_GOMX_TYPE_MP3_DEC (gst_gomx_mp3_dec_get_type ())
#define GST_GOMX_MP3_DEC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_GOMX_TYPE_MP3_DEC, GstGOmxMp3Dec))
#define GST_GOMX_MP3_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GST_GOMX_TYPE_MP3_DEC, GstGOmxMp3DecClass))
#define GST_GOMX_IS_MP3_DEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_GOMX_TYPE_MP3_DEC))
#define GST_GOMX_IS_MP3_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_GOMX_TYPE_MP3_DEC))
#define GST_GOMX_MP3_DEC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_GOMX_TYPE_MP3_DEC, GstGOmxMp3DecClass))

typedef struct _GstGOmxMp3Dec GstGOmxMp3Dec;
typedef struct _GstGOmxMp3DecClass GstGOmxMp3DecClass;
typedef struct _GstGOmxMp3DecPrivate GstGOmxMp3DecPrivate;
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _gst_event_unref0(var) ((var == NULL) ? NULL : (var = (gst_event_unref (var), NULL)))
#define _gst_buffer_unref0(var) ((var == NULL) ? NULL : (var = (gst_buffer_unref (var), NULL)))
#define _gst_structure_free0(var) ((var == NULL) ? NULL : (var = (gst_structure_free (var), NULL)))

struct _GstGOmxMp3Dec {
	GstElement parent_instance;
	GstGOmxMp3DecPrivate * priv;
};

struct _GstGOmxMp3DecClass {
	GstElementClass parent_class;
};

struct _GstGOmxMp3DecPrivate {
	GstPad* src_pad;
	GstPad* sink_pad;
};


static gpointer gst_gomx_mp3_dec_parent_class = NULL;

GType gst_gomx_mp3_dec_get_type (void);
#define GST_GOMX_MP3_DEC_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GST_GOMX_TYPE_MP3_DEC, GstGOmxMp3DecPrivate))
enum  {
	GST_GOMX_MP3_DEC_DUMMY_PROPERTY
};
static gboolean gst_gomx_mp3_dec_sink_pad_setcaps (GstGOmxMp3Dec* self, GstPad* pad, GstCaps* caps);
static gboolean _gst_gomx_mp3_dec_sink_pad_setcaps (GstPad* pad, GstCaps* caps);
static gboolean gst_gomx_mp3_dec_sink_pad_event (GstGOmxMp3Dec* self, GstPad* pad, GstEvent* event);
static gboolean _gst_gomx_mp3_dec_sink_pad_event (GstPad* pad, GstEvent* event);
static GstFlowReturn gst_gomx_mp3_dec_sink_pad_chain (GstGOmxMp3Dec* self, GstPad* pad, GstBuffer* buffer);
static GstFlowReturn _gst_gomx_mp3_dec_sink_pad_chain (GstPad* pad, GstBuffer* buffer);
static gboolean gst_gomx_mp3_dec_sink_pad_activatepush (GstGOmxMp3Dec* self, GstPad* pad, gboolean active);
static gboolean _gst_gomx_mp3_dec_sink_pad_activatepush (GstPad* pad, gboolean active);
static GstStateChangeReturn gst_gomx_mp3_dec_real_change_state (GstElement* base, GstStateChange transition);
void gst_gomx_mp3_dec_src_pad_task (GstGOmxMp3Dec* self);
static void _gst_gomx_mp3_dec_src_pad_task_gst_task_function (gpointer self);
GstGOmxMp3Dec* gst_gomx_mp3_dec_new (void);
GstGOmxMp3Dec* gst_gomx_mp3_dec_construct (GType object_type);
static GstFlowReturn __gst_gomx_mp3_dec_sink_pad_chain_gst_pad_chain_function (GstPad* pad, GstBuffer* buffer);
static gboolean __gst_gomx_mp3_dec_sink_pad_setcaps_gst_pad_set_caps_function (GstPad* pad, GstCaps* caps);
static gboolean __gst_gomx_mp3_dec_sink_pad_event_gst_pad_event_function (GstPad* pad, GstEvent* event);
static gboolean __gst_gomx_mp3_dec_sink_pad_activatepush_gst_pad_activate_mode_function (GstPad* pad, gboolean active);
static GObject * gst_gomx_mp3_dec_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gst_gomx_mp3_dec_finalize (GObject* obj);
gboolean plugin_init (GstPlugin* plugin);
static gboolean _plugin_init_gst_plugin_init_func (GstPlugin* plugin);

const GstPluginDesc gst_plugin_desc = {GST_VERSION_MAJOR, GST_VERSION_MINOR, "gomx", "Elements based on omx-vala", _plugin_init_gst_plugin_init_func, "0.1.0", "LGPL", "gst-gomx", "GstGOmx", "http://github.com/tigrux/omx-vala", {NULL}};


static gboolean _gst_gomx_mp3_dec_sink_pad_setcaps (GstPad* pad, GstCaps* caps) {
	gboolean result;
	GstObject* _tmp0_;
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (caps != NULL, FALSE);
	result = gst_gomx_mp3_dec_sink_pad_setcaps ((_tmp0_ = ((GstObject*) pad)->parent, GST_GOMX_IS_MP3_DEC (_tmp0_) ? ((GstGOmxMp3Dec*) _tmp0_) : NULL), pad, caps);
	return result;
}


static gpointer _gst_event_ref0 (gpointer self) {
	return self ? gst_event_ref (self) : NULL;
}


static gboolean _gst_gomx_mp3_dec_sink_pad_event (GstPad* pad, GstEvent* event) {
	gboolean result;
	GstObject* _tmp0_;
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	result = gst_gomx_mp3_dec_sink_pad_event ((_tmp0_ = ((GstObject*) pad)->parent, GST_GOMX_IS_MP3_DEC (_tmp0_) ? ((GstGOmxMp3Dec*) _tmp0_) : NULL), pad, _gst_event_ref0 (event));
	_gst_event_unref0 (event);
	return result;
	_gst_event_unref0 (event);
}


static gpointer _gst_buffer_ref0 (gpointer self) {
	return self ? gst_buffer_ref (self) : NULL;
}


static GstFlowReturn _gst_gomx_mp3_dec_sink_pad_chain (GstPad* pad, GstBuffer* buffer) {
	GstFlowReturn result;
	GstObject* _tmp0_;
	g_return_val_if_fail (pad != NULL, 0);
	g_return_val_if_fail (buffer != NULL, 0);
	result = gst_gomx_mp3_dec_sink_pad_chain ((_tmp0_ = ((GstObject*) pad)->parent, GST_GOMX_IS_MP3_DEC (_tmp0_) ? ((GstGOmxMp3Dec*) _tmp0_) : NULL), pad, _gst_buffer_ref0 (buffer));
	_gst_buffer_unref0 (buffer);
	return result;
	_gst_buffer_unref0 (buffer);
}


static gboolean _gst_gomx_mp3_dec_sink_pad_activatepush (GstPad* pad, gboolean active) {
	gboolean result;
	GstObject* _tmp0_;
	g_return_val_if_fail (pad != NULL, FALSE);
	result = gst_gomx_mp3_dec_sink_pad_activatepush ((_tmp0_ = ((GstObject*) pad)->parent, GST_GOMX_IS_MP3_DEC (_tmp0_) ? ((GstGOmxMp3Dec*) _tmp0_) : NULL), pad, active);
	return result;
}


static GstStateChangeReturn gst_gomx_mp3_dec_real_change_state (GstElement* base, GstStateChange transition) {
	GstGOmxMp3Dec * self;
	GstStateChangeReturn result;
	GstStateChangeReturn _result_;
	self = (GstGOmxMp3Dec*) base;
	_result_ = GST_STATE_CHANGE_SUCCESS;
	switch (transition) {
		case GST_STATE_CHANGE_NULL_TO_READY:
		{
			g_print ("*** Passing from null to ready\n");
			break;
		}
		case GST_STATE_CHANGE_READY_TO_PAUSED:
		{
			g_print ("*** Passing from ready to paused\n");
			break;
		}
		case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
		{
			g_print ("*** Passing from paused to playing\n");
			break;
		}
		default:
		{
			break;
		}
	}
	_result_ = GST_ELEMENT_CLASS (gst_gomx_mp3_dec_parent_class)->change_state (GST_ELEMENT (self), transition);
	if (_result_ == GST_STATE_CHANGE_FAILURE) {
		result = _result_;
		return result;
	}
	switch (transition) {
		case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
		{
			g_print ("*** Passing from playing to paused\n");
			break;
		}
		case GST_STATE_CHANGE_PAUSED_TO_READY:
		{
			g_print ("*** Passing from paused to ready\n");
			break;
		}
		case GST_STATE_CHANGE_READY_TO_NULL:
		{
			g_print ("*** Passing from ready to null\n");
			break;
		}
		default:
		{
			break;
		}
	}
	result = _result_;
	return result;
}


static gpointer _gst_structure_copy0 (gpointer self) {
	return self ? gst_structure_copy (self) : NULL;
}


static gboolean gst_gomx_mp3_dec_sink_pad_setcaps (GstGOmxMp3Dec* self, GstPad* pad, GstCaps* caps) {
	gboolean result;
	GstStructure* structure;
	gint rate;
	gint channels;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (caps != NULL, FALSE);
	structure = _gst_structure_copy0 (gst_caps_get_structure (caps, (guint) 0));
	rate = 0;
	channels = 0;
	gst_structure_get_int (structure, "rate", &rate);
	gst_structure_get_int (structure, "channels", &channels);
	g_print ("*** Sink Caps: rate = %d, channels=%d\n", rate, channels);
	result = gst_pad_set_caps (pad, caps);
	_gst_structure_free0 (structure);
	return result;
}


static gboolean gst_gomx_mp3_dec_sink_pad_event (GstGOmxMp3Dec* self, GstPad* pad, GstEvent* event) {
	gboolean result;
	gboolean _result_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	switch (event->type) {
		case GST_EVENT_EOS:
		{
			g_print ("*** Got eos\n");
			_result_ = gst_pad_push_event (self->priv->src_pad, _gst_event_ref0 (event));
			break;
		}
		case GST_EVENT_FLUSH_START:
		{
			g_print ("*** Starting flush\n");
			_result_ = gst_pad_push_event (self->priv->src_pad, _gst_event_ref0 (event));
			break;
		}
		case GST_EVENT_FLUSH_STOP:
		{
			g_print ("*** Stopping flush\n");
			_result_ = gst_pad_push_event (self->priv->src_pad, _gst_event_ref0 (event));
			break;
		}
		case GST_EVENT_NEWSEGMENT:
		{
			g_print ("*** Got new segment\n");
			_result_ = gst_pad_push_event (self->priv->src_pad, _gst_event_ref0 (event));
			break;
		}
		default:
		{
			_result_ = gst_pad_push_event (self->priv->src_pad, _gst_event_ref0 (event));
			break;
		}
	}
	result = _result_;
	_gst_event_unref0 (event);
	return result;
}


static void _gst_gomx_mp3_dec_src_pad_task_gst_task_function (gpointer self) {
	gst_gomx_mp3_dec_src_pad_task (self);
}


static gboolean gst_gomx_mp3_dec_sink_pad_activatepush (GstGOmxMp3Dec* self, GstPad* pad, gboolean active) {
	gboolean result;
	gboolean _result_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	if (active) {
		g_print ("*** Starting task\n");
		_result_ = gst_pad_start_task (self->priv->src_pad, _gst_gomx_mp3_dec_src_pad_task_gst_task_function, self);
	} else {
		g_print ("*** Stopping task\n");
		_result_ = gst_pad_stop_task (self->priv->src_pad);
	}
	result = _result_;
	return result;
}


static GstFlowReturn gst_gomx_mp3_dec_sink_pad_chain (GstGOmxMp3Dec* self, GstPad* pad, GstBuffer* buffer) {
	GstFlowReturn result;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (pad != NULL, 0);
	g_return_val_if_fail (buffer != NULL, 0);
	g_print ("** Chaining: %d\n", buffer->size);
	result = GST_FLOW_OK;
	_gst_buffer_unref0 (buffer);
	return result;
}


void gst_gomx_mp3_dec_src_pad_task (GstGOmxMp3Dec* self) {
	g_return_if_fail (self != NULL);
	g_print ("*** Pad tasking\n");
	gst_pad_pause_task (self->priv->src_pad);
}


GstGOmxMp3Dec* gst_gomx_mp3_dec_construct (GType object_type) {
	GstGOmxMp3Dec * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


GstGOmxMp3Dec* gst_gomx_mp3_dec_new (void) {
	return gst_gomx_mp3_dec_construct (GST_GOMX_TYPE_MP3_DEC);
}


static GstFlowReturn __gst_gomx_mp3_dec_sink_pad_chain_gst_pad_chain_function (GstPad* pad, GstBuffer* buffer) {
	return _gst_gomx_mp3_dec_sink_pad_chain (pad, buffer);
}


static gboolean __gst_gomx_mp3_dec_sink_pad_setcaps_gst_pad_set_caps_function (GstPad* pad, GstCaps* caps) {
	return _gst_gomx_mp3_dec_sink_pad_setcaps (pad, caps);
}


static gboolean __gst_gomx_mp3_dec_sink_pad_event_gst_pad_event_function (GstPad* pad, GstEvent* event) {
	return _gst_gomx_mp3_dec_sink_pad_event (pad, event);
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static gboolean __gst_gomx_mp3_dec_sink_pad_activatepush_gst_pad_activate_mode_function (GstPad* pad, gboolean active) {
	return _gst_gomx_mp3_dec_sink_pad_activatepush (pad, active);
}


static GObject * gst_gomx_mp3_dec_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GstGOmxMp3Dec * self;
	parent_class = G_OBJECT_CLASS (gst_gomx_mp3_dec_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GST_GOMX_MP3_DEC (obj);
	{
		GstPad* _tmp0_;
		GstPad* _tmp1_;
		self->priv->sink_pad = (_tmp0_ = gst_pad_new_from_template (gst_element_class_get_pad_template (GST_ELEMENT_CLASS (G_OBJECT_GET_CLASS (self)), "sink"), "sink"), _gst_object_unref0 (self->priv->sink_pad), _tmp0_);
		gst_pad_set_chain_function (self->priv->sink_pad, __gst_gomx_mp3_dec_sink_pad_chain_gst_pad_chain_function);
		gst_pad_set_setcaps_function (self->priv->sink_pad, __gst_gomx_mp3_dec_sink_pad_setcaps_gst_pad_set_caps_function);
		gst_pad_set_event_function (self->priv->sink_pad, __gst_gomx_mp3_dec_sink_pad_event_gst_pad_event_function);
		gst_element_add_pad ((GstElement*) self, _gst_object_ref0 (self->priv->sink_pad));
		self->priv->src_pad = (_tmp1_ = gst_pad_new_from_template (gst_element_class_get_pad_template (GST_ELEMENT_CLASS (G_OBJECT_GET_CLASS (self)), "src"), "src"), _gst_object_unref0 (self->priv->src_pad), _tmp1_);
		gst_pad_set_activatepush_function (self->priv->src_pad, __gst_gomx_mp3_dec_sink_pad_activatepush_gst_pad_activate_mode_function);
		gst_element_add_pad ((GstElement*) self, _gst_object_ref0 (self->priv->src_pad));
	}
	return obj;
}


static void gst_gomx_mp3_dec_base_init (GstGOmxMp3DecClass * klass) {
	{
		GstPadTemplate* _tmp2_;
		GstPadTemplate* _tmp3_;
		gst_element_class_set_details_simple (GST_ELEMENT_CLASS (klass), "gomx mp3 decoder", "Codec/Decoder/Audio", "Gst GOmx Mp3 decoder", "Tigrux <tigrux@gmail.com>");
		gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass), _tmp2_ = gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS, gst_caps_new_simple ("audio/x-raw-int", "endianness", G_TYPE_INT, G_BYTE_ORDER, "width", G_TYPE_INT, 16, "depth", G_TYPE_INT, 16, "rate", GST_TYPE_INT_RANGE, 8000, 96000, "signed", G_TYPE_BOOLEAN, TRUE, "channels", GST_TYPE_INT_RANGE, 1, 2, NULL, NULL)));
		_gst_object_unref0 (_tmp2_);
		gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass), _tmp3_ = gst_pad_template_new ("sink", GST_PAD_SINK, GST_PAD_ALWAYS, gst_caps_new_simple ("audio/mpeg", "mpegversion", G_TYPE_INT, 1, "layer", G_TYPE_INT, 3, "rate", GST_TYPE_INT_RANGE, 8000, 48000, "channels", GST_TYPE_INT_RANGE, 1, 8, "parsed", G_TYPE_BOOLEAN, TRUE, NULL, NULL)));
		_gst_object_unref0 (_tmp3_);
	}
}


static void gst_gomx_mp3_dec_class_init (GstGOmxMp3DecClass * klass) {
	gst_gomx_mp3_dec_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GstGOmxMp3DecPrivate));
	GST_ELEMENT_CLASS (klass)->change_state = gst_gomx_mp3_dec_real_change_state;
	G_OBJECT_CLASS (klass)->constructor = gst_gomx_mp3_dec_constructor;
	G_OBJECT_CLASS (klass)->finalize = gst_gomx_mp3_dec_finalize;
}


static void gst_gomx_mp3_dec_instance_init (GstGOmxMp3Dec * self) {
	self->priv = GST_GOMX_MP3_DEC_GET_PRIVATE (self);
}


static void gst_gomx_mp3_dec_finalize (GObject* obj) {
	GstGOmxMp3Dec * self;
	self = GST_GOMX_MP3_DEC (obj);
	_gst_object_unref0 (self->priv->src_pad);
	_gst_object_unref0 (self->priv->sink_pad);
	G_OBJECT_CLASS (gst_gomx_mp3_dec_parent_class)->finalize (obj);
}


GType gst_gomx_mp3_dec_get_type (void) {
	static GType gst_gomx_mp3_dec_type_id = 0;
	if (gst_gomx_mp3_dec_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (GstGOmxMp3DecClass), (GBaseInitFunc) gst_gomx_mp3_dec_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gst_gomx_mp3_dec_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GstGOmxMp3Dec), 0, (GInstanceInitFunc) gst_gomx_mp3_dec_instance_init, NULL };
		gst_gomx_mp3_dec_type_id = g_type_register_static (GST_TYPE_ELEMENT, "GstGOmxMp3Dec", &g_define_type_info, 0);
	}
	return gst_gomx_mp3_dec_type_id;
}


gboolean plugin_init (GstPlugin* plugin) {
	gboolean result;
	g_return_val_if_fail (plugin != NULL, FALSE);
	result = gst_element_register (plugin, "gomxdec-mp3", (guint) GST_RANK_PRIMARY, GST_GOMX_TYPE_MP3_DEC);
	return result;
}


static gboolean _plugin_init_gst_plugin_init_func (GstPlugin* plugin) {
	return plugin_init (plugin);
}




